module HEADER_ERROR
{
		group BGP_CONSTANT
		{
			const Oct2 	AS_Number_MTC	:= '0046'O;		//70
			const Oct2 	AS_Number_PTC1	:= '0050'O;		//80
			const Oct2 	AS_Number_PTC2	:= '0050'O;		//80
			const Oct2 	AS_Number_ROUTER 	:= '0001'O;	
			
			const Oct4 	MTC_IPv4		:= 'CA65010B'O;	//202.101.1.11
			const Oct4	PTC1_IPv4		:= 'CA650216'O;	//202.101.3.22
			const Oct4	PTC2_IPv4		:= '79650521'O;	//121.101.5.33
			
			const Oct4 	ROUTER_PCO1_IPv4 := 'CA650101'O;	//202.101.1.1
			const Oct4	ROUTER_PCO2_IPv4 := 'CA650301'O;	//202.101.3.1
			const Oct4	ROUTER_PCO3_IPv4 := '79650501'O;	//121.101.5.1
			
			const integer HOLD_TIMER 	:= 190;			//unit-s			
		}//end group BGP_CONSTANT
		
		// Common string subtypes  number indicates encoding length in number of 
		// _hex digits/chars/octets_
		type octetstring	Oct1 		length(1);
		type octetstring	Oct2 		length(2); 
		type octetstring	Oct3 		length(3); 
		type octetstring	Oct4 		length(4); 
		type octetstring	Oct6 		length(6); 
		type octetstring	Oct16 		length(16); 
		type octetstring	Oct128 		length(128); 
		//type octetstring	Oct1to128 	length(1..128); //with {encode "1 to 128 Octets"};
			
		group	PDU_TYPE
		{
			group	PDU_OPEN
			{
				type record BGP_OPEN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	VERSION,
					Oct2	MY_AS,
					Oct2	HOLDTIME,
					Oct4	ID,
					Oct1	OPTION_LEN			
				}//	end record BGP_OPEN
				
				type	record BGP_OPEN_OPT
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	VERSION,
					Oct2	MY_AS,
					Oct2	HOLDTIME,
					Oct4	ID,
					Oct1	OPTION_LEN,
					Oct1	PARM_TYPE,
					Oct1	PARM_LEN
				}// end record BGP_OPEN_OPT	
				
				type	record	BGP_OPEN_AUTH
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	VERSION,
					Oct2	MY_AS,
					Oct2	HOLDTIME,
					Oct4	ID,
					Oct1	OPTION_LEN,
					Oct1	PARM_TYPE,
					Oct1	PARM_LEN,
					Oct1	AUTH_CODE,
					Oct1	AUTH_DATA
				}// end record BGP_OPEN_AUTH
			}//end group PDU_OPEN
						
			group	PDU_NOTIFICATION
			{
				type	record	BGP_NOTIFICATION
				{
					Oct16	MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	ERR_CODE,
					Oct1	ERR_SUBCODE
				}// end record BGP_NOTIFICATION				
			}// end group	PDU_NOTIFICATION
			
			group PDU_KEEPALIVE
			{
				type record BGP_KEEPALIVE
				{
					Oct16	MARKER,
					Oct2	LENGTH,
					Oct1	TYPE
				}//	end record BGP_KEEPALIVE				
			}// end group PDU_KEEPALIVE
			
			group	PDU_UPDATE
			{
				type	record	BGP_UPDATE_ERR
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI						
				}// end record 
				
				type	record	BGP_UPDATE_CAST
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_CAST
				
				type	record	BGP_UPDATE_MIN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN
				}// end record BGP_UPDATE_MIN
				
				type	record	BGP_UPDATE_MED
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct4	NLRI
				}//end record BGP_UPDATE_MED
				
			}//end group PDU_UPDATE
			
		}//end group PDU_TYPE
		
		group	TEMPL_OPEN
		{
			template	BGP_OPEN	OPEN_SEND :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,	//180
				ID					:= MTC_IPv4,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_RECEIVE :=
			{
				MARKER 			:= ?,
				LENGTH 			:= ?,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= ?,
				HOLDTIME		:= ?,
				ID					:= ?,
				OPTION_LEN	:= ?
			};
			
			template	BGP_OPEN	OPEN_KEEPALIVE_NEGO :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '003C'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_HOLDTIME_ZERO :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '0000'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_MARKER_ERROR_1 :=
			{
				MARKER 			:= '10101010101010101010101010101010'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_LEN_LESS_MIN :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '0012'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_LEN_GREATER_MAX :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '0012'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_LEN_LESS :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001B'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_TYPE_ERROR :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '07'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
		}//end group TEMPL_OPEN
		
		group	TEMPL_NOTIFICATION
		{
			template	BGP_NOTIFICATION		NOTIFICATION_SEND :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0015'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			template	BGP_NOTIFICATION		NOTIFICATION_RECEIVE :=
			{
				MARKER			:= ?,
				LENGTH			:= ?,
				TYPE				:= '03'O,
				ERR_CODE		:= ?,
				ERR_SUBCODE	:= ?
			};
			
			template	BGP_NOTIFICATION	NOTIFICATION_UPDATE_ERROR :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0015'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			template	BGP_NOTIFICATION	NOTIFICATION_MARKER_ERROR :=
			{
				MARKER			:= '00000000000000000000000000000000'O,
				LENGTH			:= '0015'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			template	BGP_NOTIFICATION	NOTIFICATION_LEN_LESS :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0014'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			template	BGP_NOTIFICATION	NOTIFICATION_LEN_GREATER :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0018'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			template	BGP_NOTIFICATION	NOTIFICATION_LEN_LESS_MIN :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0012'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			template	BGP_NOTIFICATION	NOTIFICATION_LEN_GREATER_MAX :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '1001'O,
				TYPE				:= '03'O,
				ERR_CODE		:= '01'O,
				ERR_SUBCODE	:= '01'O
			};
			
			
			template	BGP_NOTIFICATION	CEASE :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0015'O,
				TYPE			:= '03'O,
				ERR_CODE		:= '06'O,
				ERR_SUBCODE	:= '00'O
			};
			
		}//end group TEMPL_NOTIFICATION
		
		group	TEMPL_KEEPALIVE
		{
			template	BGP_KEEPALIVE		KEEPALIVE_SEND :=
			{
				MARKER	:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH	:= '0013'O,
				TYPE		:= '04'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_RECEIVE :=
			{
				MARKER	:= ?,
				LENGTH	:= ?,
				TYPE		:= '04'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_MARKER_ERROR :=
			{
				MARKER	:= '00000000000000000000000000000000'O,
				LENGTH	:= '0013'O,
				TYPE		:= '04'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_TYPE_ERROR :=
			{
				MARKER	:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH	:= '0013'O,
				TYPE		:= '07'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_LEN_GREATER :=
			{
				MARKER	:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH	:= '0014'O,
				TYPE		:= '04'O
			};

			template	BGP_KEEPALIVE		KEEPALIVE_LEN_LESS_MIN :=
			{
				MARKER	:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH	:= '0012'O,
				TYPE		:= '04'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_LEN_GREATER_MAX :=
			{
				MARKER	:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH	:= '1001'O,
				TYPE		:= '04'O
			};
		}//end group TEMPL_KEEPALIVE
		
		group	TEMPL_UPDATE
		{
			template	BGP_UPDATE_ERR		UPDATE_SEND :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_RECEIVE :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= ?,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= ?,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= ?,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= ?,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ?,
				NLRI								:= ?
			};
			
			template	BGP_UPDATE_ERR		UPDATE_MARKER_ERROR :=
			{
				MARKER							:= '00000000000000000000000000000000'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_LEN_LESS_MIN :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0012'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_LEN_GREATER_MAX :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '1001'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MIN		UPDATE_LEN_LESS :=
			{
				MARKER						:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH						:= '0015'O,
				TYPE							:= '02'O,	
				UNFEASIBLE				:= '0000'O,
				PATHATTRIBUTE_LEN	:= '0000'O
			};
			
			template	BGP_UPDATE_CAST		UPDATE_CAST :=
			{
				MARKER						:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH						:= ?,
				TYPE							:= '02'O,
				UNFEASIBLE				:= '0000'O,
				PATHATTRIBUTE_LEN	:= ?,
				ORIGIN						:= '400101'O,
				ORIGIN_TYPE				:= '00'O,
				AS_PATH						:= '4002'O,
				AS_LEN						:= '04'O,
				AS_SEG_TYPE				:= '02'O,
				AS_SEG_LEN				:= '01'O,
				AS_SEG_VAL				:= '0001'O,
				NEXT_HOP					:= '400304'O,
				NEXT_HOT_VAL			:= ROUTER_PCO1_IPv4,
				MED								:= '800404'O,
				MED_VAL						:= ?,
				NLRI							:= ?
			};

			template	BGP_UPDATE_ERR		UPDATE_ATTR_LEN_ERROR_0 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400100'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_ATTR_LEN_ERROR_1 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '05'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_ATTR_LEN_ERROR_2 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400303'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MED		UPDATE_ATTR_LEN_ERROR_3 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0034'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0019'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				MED									:= '800402'O,
				MED_VAL							:= '00000077'O,
				NLRI								:= '14A66F80'O
			};
			
		}//end group TEMPL_UPDATE	
		
		group	Port
		{
			type port	BGP_Port	message
			{
				inout	BGP_OPEN,	BGP_KEEPALIVE
			}		
		}//end group Port
		
		group	TestAbstractComponent
		{
			type component	BGP_Component
			{
				port	BGP_Port	BGPP;
				timer	BGP_Timer_Hold := 190;
				timer	BGP_Timer_KeepAlive := 60; //unit-s
				timer	Timer_Keepalive_Nego := 25;
			
			}
		}	//end group TestAbstractComponent
		
		group	TestSystemInterface
		{
			type component BGP_Interface
			{
				port 	BGP_Port	BGP_Interface_Port; 
			}
		}//end group TestSystemInterface
		
		
		function	fun_StopAndResumeRouter() runs on BGP_Component
		{
			BGPP.send(CEASE);
			stop;
		}//end function stop
		
		function	fun_ESTABLISHED() runs on BGP_Component
		{
			BGPP.send(OPEN_SEND);
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{					
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive keepalive frame
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							BGPP.send(KEEPALIVE_SEND);
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive	
						{
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{
					setverdict(fail);
					stop;
				}	
			}//end alt 01
		}// end function	fun_ESTABLISHED()
				
		
		/*BGP error handling*/
		testcase	BGP_OPEN_MARKER()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_MARKER_ERROR_1);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_OPEN_MARKER()		
		
		testcase	BGP_UPDATE_MARKER()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGPP.send(UPDATE_MARKER_ERROR);
			BGP_Timer_Hold.start;
			label	L1;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
				{
					BGP_Timer_Hold.start;
					ErrorCode := vNotificationData.ERR_CODE;
					ErrorSubCode := vNotificationData.ERR_SUBCODE;
					if(ErrorCode=='01'O and ErrorSubCode=='01'O)
					{
						setverdict(pass);
						stop;
					}
					else
					{
						setverdict(fail);
						stop;
					}
				}
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGP_Timer_Hold.start;
					goto	L1;
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_MARKER()	
		
		testcase	BGP_NOTIFICATION_MARKER()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_SEND);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive keepalive frame
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							BGPP.send(NOTIFICATION_MARKER_ERROR);
							BGP_Timer_Hold.start;
							alt	//03
							{//wait for receive notification frame
								[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
								{
									ErrorCode := vNotificationData.ERR_CODE;
									ErrorSubCode := vNotificationData.ERR_SUBCODE;
									if(ErrorCode=='01'O and ErrorSubCode=='01'O)
									{
										setverdict(pass);
										stop;
									}
									else
									{
										setverdict(fail);
										stop;
									}
								}
								[]BGP_Timer_Hold.timeout	
								{
									setverdict(fail);
									stop;
								}	
								[]BGPP.receive	
								{					
									setverdict(fail);
									stop;
								}
							}//end alt 03
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_NOTIFICATION_MARKER()	
		
		testcase	BGP_KEEPALIVE_MARKER()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_SEND);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive keepalive frame
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							BGPP.send(KEEPALIVE_MARKER_ERROR);
							BGP_Timer_Hold.start;
							alt	//03
							{//wait for receive notification frame
								[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
								{
									ErrorCode := vNotificationData.ERR_CODE;
									ErrorSubCode := vNotificationData.ERR_SUBCODE;
									if(ErrorCode=='01'O and ErrorSubCode=='01'O)
									{
										setverdict(pass);
										stop;
									}
									else
									{
										setverdict(fail);
										stop;
									}
								}
								[]BGP_Timer_Hold.timeout	
								{
									setverdict(fail);
									stop;
								}	
								[]BGPP.receive	
								{					
									setverdict(fail);
									stop;
								}
							}//end alt 03
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_KEEPALIVE_MARKER()	
		
		testcase	BGP_OPEN_LEN_LESS_MIN()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_LEN_LESS_MIN);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_OPEN_LEN_LESS_MIN()
		
		testcase	BGP_UPDATE_LEN_LESS_MIN()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(UPDATE_LEN_LESS_MIN);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_LEN_LESS_MIN()
		
		testcase	BGP_NOTIFICATION_LEN_LESS_MIN()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(NOTIFICATION_LEN_LESS_MIN);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_NOTIFICATION_LEN_LESS_MIN()
		
		testcase	BGP_KEEPALIVE_LEN_LESS_MIN()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(KEEPALIVE_LEN_LESS_MIN);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_KEEPALIVE_LEN_LESS_MIN()
		
		testcase	BGP_OPEN_LEN_GREATER_MAX()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_LEN_GREATER_MAX);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_OPEN_LEN_GREATER_MAX()
		
		testcase	BGP_UPDATE_LEN_GREATER_MAX()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(UPDATE_LEN_GREATER_MAX);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPADATE_LEN_GREATER_MAX()
		
		testcase	BGP_NOTIFICATION_LEN_GREATER_MAX()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(NOTIFICATION_LEN_GREATER_MAX);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_NOTIFICATION_LEN_GREATER_MAX()
		
		testcase	BGP_KEEPALIVE_LEN_GREATER_MAX()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(KEEPALIVE_LEN_GREATER_MAX);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_KEEPALIVE_LEN_GREATER_MAX()
		
		testcase	BGP_OPEN_LEN_LESS()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_LEN_LESS);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_OPEN_LEN_LESS()
		
		testcase	BGP_UPDATE_LEN_LESS()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(UPDATE_LEN_LESS);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_LEN_LESS()
		
		testcase	BGP_UPDATE_LEN_LESS_1()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_LEN_LESS);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_LEN_LESS_1()
		
		testcase	BGP_NOTIFICATION_LEN_LESS()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(NOTIFICATION_LEN_LESS);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_NOTIFICATION_LEN_LESS()
		
		testcase	BGP_OPEN_TYPE()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(OPEN_TYPE_ERROR);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='03'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_OPEN_TYPE()
		
		testcase	BGP_KEEPALIVE_TYPE()	runs on BGP_Component system BGP_Interface
		{
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{
					BGPP.send(KEEPALIVE_TYPE_ERROR);
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='01'O and ErrorSubCode=='03'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_KEEPALIVE_TYPE()
		
		testcase	BGP_UPDATE_ATTR_LEN_01()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_0.ORIGIN:='400102'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_0);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_01()
		
		testcase	BGP_UPDATE_ATTR_LEN_02()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_0.ORIGIN:='400109'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_0);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_02()
		
		testcase	BGP_UPDATE_ATTR_LEN_11()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_1.AS_LEN:='05'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_1);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_11()
		
		testcase	BGP_UPDATE_ATTR_LEN_12()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_1.AS_LEN:='09'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_1);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_12()
		
		testcase	BGP_UPDATE_ATTR_LEN_21()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_2.NEXT_HOP := '400305'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_2);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_21()
		
		testcase	BGP_UPDATE_ATTR_LEN_22()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_2.NEXT_HOP := '400309'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_2);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_22()
		
		testcase	BGP_UPDATE_ATTR_LEN_31()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_3.MED := '800405'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_3);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_31()
		
		testcase	BGP_UPDATE_ATTR_LEN_32()	runs on BGP_Component system BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var 	integer	HoldTimerValue := 190;
			
			var	Oct1		ErrorCode := '00'O;
			var	Oct1		ErrorSubCode :='00'O;
			
			var 	BGP_NOTIFICATION		vNotificationData;
			
			map(mtc:BGPP, system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
			
			BGP_Timer_KeepAlive.start;
			alt	//01
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					UPDATE_ATTR_LEN_ERROR_3.MED := '800409'O;
					BGPP.send(UPDATE_ATTR_LEN_ERROR_3);
					HoldTimerValue := HOLD_TIMER;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt	//02
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='05'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							BGP_Timer_Hold.start(HoldTimerValue);
							goto	L1;
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}	
						[]BGPP.receive	
						{					
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_KeepAlive.timeout	
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{					
					setverdict(fail);
					stop;
				}
			}// end alt 01
		}// end testcase BGP_UPDATE_ATTR_LEN_32()
		
}//end module HEADER_ERROR
