module UPDATE_ERROR_1
{
		group BGP_CONSTANT
		{
			const Oct2 AS_Number		:= '0046'O;		//70
			const Oct4 MY_IPv4		:= 'C0A801C3'O;		//192.168.1.195
			const Oct2 AS_Number_I	:= '0001'O;
			const Oct4 ROUTER_IPv4	:= 'C0A801A5'O;		//192.168.1.165
			const Oct4 AUX_IP			:= 'B2010102'O;		//178.1.1.2
			const integer HOLD_TIMER 	:= 190;
			const Oct2 TimeToWait 		:= '0000'O; 
			const Oct2 ROUTER_AS 	:= '0001'O;		//1
		}//end group BGP_CONSTANT
		
		// Common string subtypes  number indicates encoding length in number of 
		// _hex digits/chars/octets_
		type octetstring	Oct1 		length(1);
		type octetstring	Oct2 		length(2); 
		type octetstring	Oct3 		length(3); 
		type octetstring	Oct4 		length(4); 
		type octetstring	Oct6 		length(6); 
		type octetstring	Oct16 		length(16); 
		type octetstring	Oct128 		length(128); 
		//type octetstring	Oct1to128 	length(1..128); //with {encode "1 to 128 Octets"};
			
		group	PDU_TYPE
		{
			group	PDU_OPEN
			{
				type 	record BGP_OPEN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	VERSION,
					Oct2	MY_AS,
					Oct2	HOLDTIME,
					Oct4	ID,
					Oct1	OPTION_LEN			
				}//end record BGP_OPEN	
			}//end group PDU_OPEN
			
			group	PDU_NOTIFICATION
			{
				type		record	BGP_NOTIFICATION
				{
					Oct16	MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	ERR_CODE,
					Oct1	ERR_SUBCODE
				}// end record BGP_NOTIFICATION	
				
			}// end group	PDU_NOTIFICATION
			
			group PDU_KEEPALIVE
			{
				type		record BGP_KEEPALIVE
				{
					Oct16	MARKER,
					Oct2	LENGTH,
					Oct1	TYPE
				}//	end record BGP_KEEPALIVE				
			}// end group PDU_KEEPALIVE
			
			group	PDU_UPDATE
			{
				type		record	BGP_UPDATE_CAST
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_CAST
				
				type		record	BGP_UPDATE_ERR
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI						
				}// end record BGP_UPDATE_ERR
				
				type		record	BGP_UPDATE_LESS_ORIGIN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_LESS_ORIGIN
				
				type		record	BGP_UPDATE_LESS_AS_PATH
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_LESS_AS_PATH
				
				type		record	BGP_UPDATE_LESS_NEXT_HOP
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_LESS_NEXT_HOP
				
				type		record	BGP_UPDATE_WELL_KNOWN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	WELL_KNOWN,
					Oct4	NLRI	
				}// end record BGP_UPDATE_WELL_KNOWN
				
				type		record	BGP_UPDATE_MORE_ORIGIN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct3	MORE_ORIGIN,
					Oct1	MORE_ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_MORE_ORIGIN
				
				type		record	BGP_UPDATE_MORE_AS_PATH
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct2	MORE_AS_PATH,
					Oct1	MORE_AS_LEN,
					Oct1	MORE_AS_SEG_TYPE,
					Oct1	MORE_AS_SEG_LEN,
					Oct2	MORE_AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI					
				}// end record BGP_UPDATE_MORE_AS_PATH
				
				type		record	BGP_UPDATE_MORE_NEXT_HOP
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MORE_NEXT_HOP,
					Oct4	MORE_NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_MORE_NEXT_HOP
				
				type		record	BGP_UPDATE_MORE_MED
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct3	MORE_MED,
					Oct4	MORE_MED_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_MORE_MED
				
				type		record	BGP_UPDATE_MORE_LOCAL_PREF
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,	
					Oct3	LOCAL_PREF,
					Oct4	LOCAL_PREF_VAL,
					Oct3	MORE_LOCAL_PREF,
					Oct4	MORE_LOCAL_PREF_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_MORE_LOCAL_PREF
				
				type		record	BGP_UPDATE_MORE_ATOMIC
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,	
					Oct3	ATOMIC_AGGRE,
					Oct3	MORE_ATOMIC_AGGRE,
					Oct4	NLRI
				}// end record BGP_UPDATE_MORE_ATOMIC
				
				type		record	BGP_UPDATE_MORE_AGGREGATE
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	AGGREGATOR,
					Oct2	AGGREGATE_AS,
					Oct4	AGGREGATE_IP,
					Oct3	MORE_AGGREGATOR,
					Oct2	MORE_AGGREGATE_AS,
					Oct4	MORE_AGGREGATE_IP,
					Oct4	NLRI
				}// end record BGP_UPDATE_MORE_AGGREGATE				
			}//end group PDU_UPADATE
			
		}//end group PDU_TYPE
		
		
		group	TEMPL_OPEN
		{
			template	BGP_OPEN	OPEN_RECEIVE :=
			{
				MARKER 			:= ?,
				LENGTH 			:= ?,
				TYPE			:= '01'O,
				VERSION			:= '04'O,
				MY_AS			:= ?,
				HOLDTIME		:= ?,
				ID			:= ?,
				OPTION_LEN		:= ?
			};
			
			template	BGP_OPEN	OPEN_SEND :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE			:= '01'O,
				VERSION			:= '04'O,
				MY_AS			:= AS_Number,
				HOLDTIME		:= '00B4'O,	//180
				ID			:= MY_IPv4,
				OPTION_LEN		:= '00'O
			};
		}//end group	TEMPL_OPEN
		
		group	TEMPL_NOTIFICATION
		{
			template	BGP_NOTIFICATION		NOTIFICATION_RECEIVE :=
			{
				MARKER			:= ?,
				LENGTH			:= ?,
				TYPE			:= '03'O,
				ERR_CODE		:= ?,
				ERR_SUBCODE	:= ?
			};
			
			template	BGP_NOTIFICATION	CEASE :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0015'O,
				TYPE			:= '03'O,
				ERR_CODE		:= '06'O,
				ERR_SUBCODE	:= '00'O
			};
			
		}//end group TEMPL_NOTIFICATION
		
		group	TEMPL_KEEPALIVE
		{
			template	BGP_KEEPALIVE		KEEPALIVE_SEND :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '0013'O,		//19
				TYPE			:= '04'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_RECEIVE :=
			{
				MARKER	:= ?,
				LENGTH	:= ?,
				TYPE	:= '04'O
			};
		}//end group TEMPL_KEEPALIVE
		
		group	TEMPL_UPDATE
		{
			template	BGP_UPDATE_CAST		UPDATE_CAST :=
			{
				MARKER						:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH						:= ?,
				TYPE							:= '02'O,
				UNFEASIBLE				:= '0000'O,
				PATHATTRIBUTE_LEN	:= ?,
				ORIGIN						:= '400101'O,
				ORIGIN_TYPE				:= '00'O,
				AS_PATH						:= '4002'O,
				AS_LEN						:= '04'O,
				AS_SEG_TYPE				:= '02'O,
				AS_SEG_LEN				:= '01'O,
				AS_SEG_VAL				:= '0001'O,
				NEXT_HOP					:= '400304'O,
				NEXT_HOT_VAL			:= ROUTER_IPv4,
				MED								:= '800404'O,
				MED_VAL						:= ?,
				NLRI							:= ?
			};			
				
			template	BGP_UPDATE_LESS_ORIGIN	UPDATE_LESS_ORIGIN_ERROR :=
			{
				MARKER						:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH						:= '0029'O,
				TYPE							:= '02'O,
				UNFEASIBLE				:= '0000'O,
				PATHATTRIBUTE_LEN	:= '000E'O,
				AS_PATH						:= '4002'O,
				AS_LEN						:= '04'O,
				AS_SEG_TYPE				:= '02'O,
				AS_SEG_LEN				:= '01'O,
				AS_SEG_VAL				:= AS_Number,
				NEXT_HOP					:= '400304'O,
				NEXT_HOT_VAL			:= MY_IPv4,
				NLRI							:= '14A66F80'O
			};
			
			template	BGP_UPDATE_LESS_AS_PATH		UPDATE_LESS_ASPATH_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0026'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '000B'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_LESS_NEXT_HOP		UPDATE_LESS_NEXTHOP_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0026'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '000B'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_WELL_KNOWN		UPDATE_WELL_KNOWN_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0030'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0015'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				WELL_KNOWN				:= '40A000'O,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_ORIGIN_VAL_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '04'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_NEXT_HOP_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= 'FFFFFFFF'O,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_NEXT_HOP_ERROR_01 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= 'E0000007'O,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_AS_PATH_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '07'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_ORIGIN		UPDATE_MORE_ORIGIN_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0031'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0016'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				MORE_ORIGIN						:= '400101'O,
				MORE_ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_AS_PATH		UPDATE_MORE_AS_PATH_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0034'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0019'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				MORE_AS_PATH					:= '4002'O,
				MORE_AS_LEN					:= '04'O,
				MORE_AS_SEG_TYPE				:= '02'O,
				MORE_AS_SEG_LEN					:= '01'O,
				MORE_AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_NEXT_HOP		UPDATE_MORE_NEXT_HOP_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0034'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0019'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				MORE_NEXT_HOP						:= '400304'O,
				MORE_NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_MED		UPDATE_MORE_MED_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '003B'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0020'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				MED					:= '800404'O,
				MED_VAL					:= '00000000'O,
				MORE_MED				:= '800404'O,
				MORE_MED_VAL				:= '00000000'O,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_LOCAL_PREF		UPDATE_MORE_LOCAL_PREF_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '003B'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0020'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				LOCAL_PREF					:= '400504'O,
				LOCAL_PREF_VAL					:= '00000077'O,
				MORE_LOCAL_PREF				:= '400504'O,
				MORE_LOCAL_PREF_VAL				:= '00000077'O,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_ATOMIC		UPDATE_MORE_ATOMIC_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0033'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0018'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				ATOMIC_AGGRE					:= '400600'O,
				MORE_ATOMIC_AGGRE				:= '400600'O,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_MORE_AGGREGATE		UPDATE_MORE_AGGRE_ERROR :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '003F'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0024'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE						:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				AGGREGATOR					:= 'C00706'O,
				AGGREGATE_AS					:= AS_Number,
				AGGREGATE_IP					:= MY_IPv4,
				MORE_AGGREGATOR					:= 'C00706'O,
				MORE_AGGREGATE_AS					:= AS_Number,
				MORE_AGGREGATE_IP					:= MY_IPv4,
				NLRI								:= '14A66F80'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_INVALID_NLRI :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14000000'O
			};
			template	BGP_UPDATE_ERR		UPDATE_INVALID_NLRI_01 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MY_IPv4,
				NLRI								:= '14E00000'O
			};
		}//end group TEMPL_UPADATE
		
		
		group	Port
		{
			type port	BGP_Port	message
			{
				inout	all;
			}		
		}//end group Port
		
		group	TestAbstractComponent
		{
			type component	BGP_Component
			{
				port		BGP_Port		BGPP;
				timer	BGP_Timer_Hold 		:= 190;
				timer	BGP_Timer_KeepAlive 	:= 60; //unit-s
				timer	Timer_Keepalive_Nego	 := 25;
			
			}
		}	//end group TestAbstractComponent
		
		group	TestSystemInterface
		{
			type component BGP_Interface
			{
				port 	BGP_Port		BGP_Interface_Port; 
			}
		}//end group TestSystemInterface
						
		function	fun_ESTABLISHED() runs on BGP_Component
		{
			BGPP.send(OPEN_SEND);
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{					
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive keepalive frame
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							BGPP.send(KEEPALIVE_SEND);
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive	
						{
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{
					setverdict(fail);
					stop;
				}	
			}//end alt 01
		}// end function	fun_ESTABLISHED()
		
		
		/*Update frame errors*/
		testcase	BGP_LESS_ORIGIN()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_LESS_ORIGIN_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='03'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_LESS_ORIGIN
		
		testcase	BGP_LESS_ASPATH()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_LESS_ASPATH_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='03'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_LESS_ASPATH
		
		testcase	BGP_LESS_NEXTHOP()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_LESS_NEXTHOP_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='03'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_LESS_NEXTHOP
		
		testcase	BGP_UNRECEIVE_WELLKNOWN()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_WELL_KNOWN_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='02'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_UNRECEIVE_WELLKNOWN
		
		testcase	BGP_ORIGIN_VAL()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_ORIGIN_VAL_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='06'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_ORIGIN_VAL
		
		testcase	BGP_NEXT_HOP()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_NEXT_HOP_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='08'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_NEXT_HOP
		
		testcase	BGP_NEXT_HOP_1()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_NEXT_HOP_ERROR_01);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='08'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_NEXT_HOP_1
		
		testcase	BGP_ASPATH_ERROR_1()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_AS_PATH_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='0B'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_ASPATH_ERROR_1
		
		testcase	BGP_MORE_ORIGIN()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_ORIGIN_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_ORIGIN
		
		testcase	BGP_MORE_AS_PATH()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_AS_PATH_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_AS_PATH
		
		testcase	BGP_MORE_NEXT_HOP()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_NEXT_HOP_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_NEXT_HOP
		
		testcase	BGP_MORE_MED()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_MED_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_MED		
		
		testcase	BGP_MORE_ATOMIC()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_ATOMIC_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_ATOMIC
		
		testcase	BGP_MORE_AGGRE()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_AGGRE_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_AGGRE
		
		testcase	BGP_NLRI()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_INVALID_NLRI);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='0A'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_NLRI
		
		testcase	BGP_NLRI_1()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			fun_ESTABLISHED();
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_INVALID_NLRI_01);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='0A'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_NLRI_1
		
		testcase	BGP_MORE_LOCAL_PREF()	runs on	BGP_Component	system	BGP_Interface
		{
			var	integer	KeepTimerValue := 60;
			var integer	HoldTimerValue := 190;
			
			var		Oct1	ErrorCode := '00'O;
			var		Oct1	ErrorSubCode :='00'O;
			
			var BGP_NOTIFICATION vNotificationData;
					
			map(mtc:BGPP,system:BGP_Interface_Port);
			
			//fun_ESTABLISHED();
			OPEN_SEND.MY_AS := AS_Number_I;
			BGPP.send(OPEN_SEND);
			BGP_Timer_Hold.start;
			alt	//01
			{//wait for receive open frame
				[]BGPP.receive(OPEN_RECEIVE)
				{					
					BGP_Timer_Hold.start;
					alt	//02
					{//wait for receive keepalive frame
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							BGPP.send(KEEPALIVE_SEND);
						}
						[]BGP_Timer_Hold.timeout	
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive	
						{
							setverdict(fail);
							stop;
						}
					}//end alt 02
				}
				[]BGP_Timer_Hold.timeout
				{
					setverdict(fail);
					stop;
				}	
				[]BGPP.receive	
				{
					setverdict(fail);
					stop;
				}	
			}//end alt 01
						
			BGP_Timer_KeepAlive.start;
			alt
			{//wait for receive keepalive frame
				[]BGPP.receive(KEEPALIVE_RECEIVE)
				{
					BGPP.send(UPDATE_MORE_LOCAL_PREF_ERROR);
					HoldTimerValue := HOLD_TIMER;
					
					//label	L1;
					BGP_Timer_Hold.start(HoldTimerValue);
					label	L1;
					alt
					{//wait for receive notification frame
						[]BGPP.receive(NOTIFICATION_RECEIVE)-> value vNotificationData
						{
							ErrorCode := vNotificationData.ERR_CODE;
							ErrorSubCode := vNotificationData.ERR_SUBCODE;
							if(ErrorCode=='03'O and ErrorSubCode=='01'O)
							{
								setverdict(pass);
								stop;
							}
							else
							{
								setverdict(fail);
								stop;
							}
						}
						[]BGPP.receive(KEEPALIVE_RECEIVE)
						{
							HoldTimerValue := HoldTimerValue - KeepTimerValue;
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGPP.receive(UPDATE_CAST)
						{
							//BGP_Timer_Hold.stop;
							BGP_Timer_Hold.start(HoldTimerValue);
							goto L1;
						}
						[]BGP_Timer_Hold.timeout
						{
							setverdict(fail);
							stop;
						}
						[]BGPP.receive
						{
							setverdict(fail);
							stop;
						}						
					}//end alt BGP_Timer_Hold
				}
				[]BGPP.receive
				{
					setverdict(fail);
					stop;
				}
				[]BGP_Timer_KeepAlive.timeout
				{
					setverdict(fail);
					stop;
				}
			}//end alt BGP_Timer_KeepAlive
		}//end testcase BGP_MORE_LOCAL_PREF
		
}//end module UPDATE_ERROR_1
