/*
 * Created on 2005-3-28
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 
//package cn.edu.tsinghua.cs.cnpt.ttcn.tools;

import java.io.*;
import java.lang.reflect.Method;

//import java.net.DatagramPacket;
import java.net.Socket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Vector;
/*
import cn.edu.tsinghua.cs.cnpt.ttcn.tci.TciEncoding;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TestAdapter;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TriMessageImpl;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TriParameterImpl;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TriStatusImpl;
*/
import cn.edu.tsinghua.cs.cnpt.ttcn.tci.TciEncoding;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TestAdapter;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TriMessageImpl;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TriParameterImpl;
import cn.edu.tsinghua.cs.cnpt.ttcn.tri.TriStatusImpl;
import cn.edu.tsinghua.cs.cnpt.ttcn.runtime.AbstractBaseCodec;
import  cn.edu.tsinghua.cs.cnpt.ttcn.runtime.BaseCodec;

import org.etsi.ttcn.tci.TciCDProvided;
import org.etsi.ttcn.tri.*;

/**
 * @author Administrator
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class BGP_TestAdapter extends TestAdapter implements TriCommunicationSA,TriPlatformPA, TciEncoding 
{
	private final int MSG_BUF_SIZE = 1600; // default data size
	private Object threadlock = new Object();
	private Thread tcpReceiverThread = null;
	private boolean runThread = false;
	private Socket rxSocket; // the receiver UDP socket used for asynchronous communication
	private Socket txSocket; // the transmitter UDP socket used for asynchronous communication
	InputStream is;
	OutputStream os;
    
	public BGP_TestAdapter()
	{
		super();
	}

	/**
	 * Returns a codec being capable of coding according to encodingName.
	 *
	 * @param encodingName the encoding name as described by the <code>with
	 *        encoding</code> attribute in the TTCN-3 module.
	 *
	 * @return TciCDProvided A codec implementing the <code>TciCDProvided</code> interface.
	 *
	 */
	 public TciCDProvided getCodec(String encodingName)
	 {
		 if ((encodingName == null) || encodingName.equals(""))
		 {
			 //encodingName = "Sync";
			 encodingName = "BaseCodec";
		 }

		 TciCDProvided codec = super.getCodec(encodingName);

		 if (codec != null)
		 {
			 return codec;
		 }

		 if (encodingName.equals("BaseCodec"))
		 {// if with encoding is not set
			 codec = new BaseCodec(RB);
			 codecs.put(encodingName, codec);
		 }
		 /*else if (encodingName.equals("Async"))
		 {
			 codec = new AsyncCodec(RB);
			 codecs.put(encodingName, codec);
		 }
		 else if (encodingName.equals("BGPc"))
		 {
			 codec = new BGPcCodec(RB);
			 codecs.put(encodingName, codec);
		 }*/
		 else
		 { // the encoding is unknown
			 RB.getTciTMProvided().tciError("Unknown decoding " + encodingName);
		 }
		 // endif encodingName
		 return codec;
	 } // end public TciCDProvided getCodec()

	 /**
	 * Execution of the test case will be cancelled by the test manager.
	 */
	 public void triCancel()
	 {
	     // SUT = null;
	     synchronized (threadlock)
	     {
		     if (!runThread)
		     { return; }
	      	     runThread = false;
	     }

	     while (tcpReceiverThread.isAlive())
	     {
		     try
		     { sleep(500); }
		     catch (InterruptedException ie) 
		     {
			     //quicknotepad.textArea.append("\n"+ie.toString());
				 RB.logging.logDatapackets("\n"+ie.toString()); 
		     }
	     }

	     if (rxSocket != null)
	     {
		     try 
		     {
			     rxSocket.close();
			     rxSocket = null;
		     }
		     catch (IOException sio)
		     {
			     //quicknotepad.textArea.append("\n"+sio.toString());
				 RB.logging.logDatapackets("\n"+sio.toString());
		     }
	     }
	 } //end public void cancel()

   
   	public TriStatus triCall(TriComponentId componentId, TriPortId tsiPortId,TriAddress sutAddress, TriSignatureId signatureId,TriParameterList parameterList)
	{
		/*Object callReturnValue;
		// the port specified in the ATS
		if (tsiPortId.getPortName().equals("SystemPort"))
		{
		    Object[] params = null;
				try
		    {
			params = parseInParameterList(parameterList);
		    }
				catch (RuntimeException tex) {
					return new TriStatusImpl("Error in parsing parameter list: " +
					tex.getMessage());
				}
		    Method[] methods = SUT.getClass().getMethods();
	
		    // search the respective method
		    for (int i = methods.length; i-- > 0;)
		    {
			if (methods[i].getName().equals(signatureId.getSignatureName()))
			{
			    try
			    {
				Class returnType = methods[i].getReturnType();
				callReturnValue = methods[i].invoke(SUT, params);
			       
				if (returnType != Void.TYPE)
				{
				    TriParameter encodedReply = new TriParameterImpl(encodeObject(
						callReturnValue),
					    TriParameterPassingMode.TRI_INOUT);
				    Cte.triEnqueueReply(tsiPortId, sutAddress,
					componentId, signatureId, parameterList,
					encodedReply);
				}
				else
				{
				    Cte.triEnqueueReply(tsiPortId, sutAddress,
					componentId, signatureId, parameterList, null);
				}
	
				return new TriStatusImpl();
			    }
			    catch (Exception iax)
			    {
				iax.printStackTrace();
	
				return new TriStatusImpl("Access violation: " +
				    iax.getMessage());
			    }
			}
		    }*/

		return new TriStatusImpl("triCall: (from: " + componentId +", to: " + tsiPortId + ",SUT address: " + sutAddress +", signature: " + signatureId + ", with paramaters: " +parameterList + ") could not be initiated");	    
		/*}
		else
		{
			return new TriStatusImpl("triCall: (from: " + componentId +", to: " + tsiPortId + ",SUT address: " + sutAddress +", signature: " + signatureId + ", with paramaters: " + parameterList + ") not implemented");
		}*/
	} //end public TriStatus triCall()

	/**
	* This operation is called by the TE immediately before the execution of
	* any test case. The test case that is going to be executed is indicated
	* by the testCaseId.
	*
	* @param testcase identifier of the test case that is going to be executed
	* @param tsiList a list of test system interface ports defined for the
	*        test system
	*
	* @return The return status of the triExecuteTestcase operation. The
	*         return status indicates the local success (TRI_OK) or failure
	*         (TRI_Error) of the operation.
	*/
	public TriStatus triExecuteTestcase(TriTestCaseId testcase,TriPortIdList tsiList)
	{
		return new TriStatusImpl();
	} // end public TriStatus triExecuteTestcase()

	/**
	* Maps a test component port to a system port.
	*
	* @param compPortId a port reference to the component port
	* @param tsiPortId a port reference to the system port.
	*
	* @return <code>TRI_OK</code> if <code>triMap</code> could be executed
	*         sucessfully <code>TRI_ERROR</code>, otherwise
	*/
	public TriStatus triMap(final TriPortId compPortId,final TriPortId tsiPortId) //throws IOException
	{
		//quicknotepad.textArea.append("naive6 CsaDef:"+CsaDef.toString());
		//RB.logging.logDatapackets("naive6 CsaDef:"+CsaDef.toString());
		//CsaDef: TACReflection;triMap->tciMapReq->tciMap;;
		//Do Some Pre_work;
		TriStatus mapStatus = CsaDef.triMap(compPortId, tsiPortId);        
        
		if (mapStatus.getStatus() != TriStatus.TRI_OK)
		{ return mapStatus; }

        	// the port specified in the ATS        
		//quicknotepad.textArea.append("naive6\t"+tsiPortId.getPortName());
		//RB.logging.logDatapackets("naive6\t"+tsiPortId.getPortName());
		if (tsiPortId.getPortName().equals("BGP_Interface_Port"))
		{
			// prepare to be ready to communicate           
			try
			{
				InetAddress routeraddr = InetAddress.getByName("192.168.1.165");
				int BGPport = 179;
				rxSocket = new Socket(routeraddr,BGPport);
            	
				is = rxSocket.getInputStream();
				os = rxSocket.getOutputStream();
				runThread = true;
				tcpReceiverThread = new Thread()
				{
					public void run() 
					{
						boolean mylock = runThread;
						try 
						{
							rxSocket.setSoTimeout(10000);			  
							while (mylock) 
							{
								byte[] msg = new byte[MSG_BUF_SIZE];
								try 
								{
									int length = rxSocket.getInputStream().read(msg);	
									if(length == -1)
									{
										throw new Exception("TCP connection finished.");
									}
									if (length > 0) 
									{
										//quicknotepad.textArea.append("\nMyBGPTestAdapter: Received ( " + length + " bytes)\n----------------\n" + new String(msg, 0, length));
										RB.logging.logDatapackets("\n\nMyBGPTestAdapter: Received ( " + length + " bytes)" );
										// It is a asynchronous message
										byte[] Con = new byte[length];
										for (int i=0;i<length;i++) Con[i]=msg[i];
										
										//print the receive message
										//quicknotepad.packetArea.append("\nReceiving  Length= "+Con.length+"bytes Packet :");
										RB.logging.logDatapackets("\nReceiving  Length= "+Con.length+"bytes Packet :");
										for (int j =0;j<Con.length;j++)
										{
											if(j%16==0)
												//quicknotepad.packetArea.append("\n");
												RB.logging.logDatapackets("\n");
											StringBuffer hexvalue=new StringBuffer(Integer.toHexString((int)((Con[j]+256)%256)));
											if(hexvalue.length()==1)
												hexvalue=hexvalue.insert(0,"0");
											//quicknotepad.packetArea.append(hexvalue+" ");
											RB.logging.logDatapackets(hexvalue+" ");
										}
										//quicknotepad.packetArea.append("\n");
										//RB.logging.logDatapackets("\n");
										//end print the receive message										
                              
										TriMessage rcvMessage = new TriMessageImpl(Con);
										//quicknotepad.textArea.append("In the Received Thread:"+ rcvMessage.getEncodedMessage().length);
										RB.logging.logDatapackets("\nIn the Received Thread:\t received message length:"+ rcvMessage.getEncodedMessage().length);
										synchronized (threadlock) 
										{
											if (runThread) 
											{
												Cte.triEnqueueMsg(tsiPortId, null, compPortId.getComponent(),rcvMessage);
											}
										}
									}
								}
								catch (InterruptedIOException iioex) 
								{
									RB.logging.logDatapackets("\n"+iioex.toString());
								}
								catch (IOException ioex) 
								{
									RB.logging.logDatapackets("\n"+ioex.toString());
									if (rxSocket != null) 
									{
										rxSocket.close();
										rxSocket = null;
									}
									return;
								}
								catch (Exception ex) 
								{
									RB.logging.logDatapackets("\n"+ex.toString());
									if (rxSocket != null) 
									{
										rxSocket.close();
										rxSocket = null;
									}
									return;
								}
								synchronized (threadlock) 
								{
									mylock = runThread;
								}
							}

							if (rxSocket != null) 
							{
								rxSocket.close();
								rxSocket = null;
							}
						}
						catch (IOException se) 
						{
							//quicknotepad.textArea.append("\n"+"MyTestAdapter: SocketException "+se.toString());
							RB.logging.logDatapackets("\n"+"MyTestAdapter: SocketException "+se.toString());
						}
					}
				};
				tcpReceiverThread.start(); 
			}
			catch (SocketException sex)
			{
				//quicknotepad.textArea.append("\n"+sex.toString());
				RB.logging.logDatapackets("\n"+sex.toString());
				return new TriStatusImpl("Unable to open socket for TSI Port: " +tsiPortId.getPortName());
			}
			catch (IOException sio)
			{
				//quicknotepad.textArea.append("\n"+sio.toString());		    
				RB.logging.logDatapackets("\n"+sio.toString());	
			}
			// listen on the receiver socket            
		}
		else
		{// Indicates an error. Attention: NOT TRI CONFORM !
			return new TriStatusImpl("triMap: (from: " + compPortId + ", to: " +tsiPortId + ") not implemented");
		}
		return new TriStatusImpl();
	} // end public TriStatus triMap()

	/**
	* This operation is called by the TE when it executes a TTCN-3 send
	* operation on a component port, which has been mapped to a TSI port.
	* This operation is called by the TE for all TTCN-3 send operations if no
	* system component has been specified for a test case, i.e., only a MTC
	* test component is created for a test case.  The encoding of sendMessage
	* has to be done in the TE prior to this TRI operation call.
	*
	* @param componentId identifier of the sending test component
	* @param tsiPortId identifier of the test system interface port via which
    	*        the message is sent to the SUT Adapter
	* @param address (optional) destination address within the SUT
	* @param sendMessage the encoded message to be send
	*
	* @return The return status of the triSend operation. The return status
	*         indicates the local success (TRI_OK) or failure (TRI_Error) of
	*         the operation.
	*/
	public TriStatus triSend(TriComponentId componentId, TriPortId tsiPortId,TriAddress address, TriMessage sendMessage)
	{
		//quicknotepad.textArea.append("Begin the triSend():\t"+sendMessage.getEncodedMessage());
		RB.logging.logDatapackets("Begin the triSend():\t");
		try
		{
			byte[] mesg = sendMessage.getEncodedMessage();
			//quicknotepad.textArea.append("MyBGPTestAdapter: Sending (to:Router )"+ mesg.length+" Btyes\n-------\n" + new String(mesg));
			RB.logging.logDatapackets("MyBGPTestAdapter: Sending (to:Router )"+ mesg.length+" Btyes\n" );
			os.write(mesg);
			//os.flush();
			//print the send messege
			//quicknotepad.packetArea.append("\nSending  Length= "+mesg.length+"bytes Packet :");
			RB.logging.logDatapackets("\nSending  Length= "+mesg.length+"bytes Packet :");
			for (int j =0;j<mesg.length;j++)
			{
				if(j%16==0)
					{ 
						//quicknotepad.packetArea.append("\n"); 
						RB.logging.logDatapackets("\n");
					}
				StringBuffer hexvalue=new StringBuffer(Integer.toHexString((int)((mesg[j]+256)%256)));
				if(hexvalue.length()==1)
					{ hexvalue=hexvalue.insert(0,"0"); }
				//quicknotepad.packetArea.append(hexvalue+" ");
				RB.logging.logDatapackets(hexvalue+" ");
			} //print the packet of sending
			return new TriStatusImpl();
		}
		catch (Exception ioex)
		{
			//quicknotepad.textArea.append("\n"+ioex.toString());
			RB.logging.logDatapackets("\n"+ioex.toString());
			return new TriStatusImpl(ioex.getMessage());
		}
	} // end public TriStatus triSend()

	/**
	* Unmaps a test component port from a system port.
	*
	* @param compPortId A port reference to the component port
	* @param tsiPortId A port reference to the system port
	*
	* @return TRI_Error in case a connection could not be closed successfully
	*         or no such connection has been established previously, TRI_OK
	*         otherwise. The operation returns TRI_OK in case no dynamic
	*         connections have to be established by the test system.
	*/
	public TriStatus triUnmap(TriPortId compPortId, TriPortId tsiPortId)
	{
		TriStatus mapStatus = CsaDef.triUnmap(compPortId, tsiPortId);

		if (mapStatus.getStatus() != TriStatus.TRI_OK)
		{ return mapStatus; }
	        if (tsiPortId.getPortName().equals("BGP_Interface_Port"))
		{// stop listening
			synchronized (threadlock)
			{
				if (!runThread)
				{ return new TriStatusImpl(); }
				runThread = false;
			}

			while (tcpReceiverThread.isAlive())
			{
				try
				{ sleep(500); }
				catch (InterruptedException ie) 
				{
					//quicknotepad.textArea.append("\n"+ie.toString());
					RB.logging.logDatapackets("\n"+ie.toString());
				}
			}
			// close the sender socket
			if (rxSocket != null)
			{
				try
				{
					rxSocket.close();
					rxSocket = null;
				}
				catch (IOException sio)
				{
					//quicknotepad.textArea.append("\n"+sio.toString());
					RB.logging.logDatapackets("\n"+sio.toString());
				}
			}
			return new TriStatusImpl();
		}
		else
		{
			// Indicates an error. Attention: NOT TRI CONFORM !	
			// TRI Conformant would be 
			// return new TriStatusImpl(TRI_ERROR); // no description
			return new TriStatusImpl("triUnmap: (from: " + compPortId +", to: " + tsiPortId + ") not implemented");
		}
	} //end public TriStatus triUnmap()

	    /* 
	    private Object decodeEncodedParameter(byte[] parameter) throws RuntimeException
	    {
		return ((SyncCodec) getCodec("")).deserializeObject(parameter);
	    }
	
	    private byte[] encodeObject(Object returnValue) throws IOException
	    {
		return ((SyncCodec) getCodec("")).serializeObject(returnValue);
	    }
	
	    private Object[] parseInParameterList(TriParameterList params) throws RuntimeException
		//throws TciException
	    {
		// temporary storage
		Vector objectList = new Vector();
	
		// find IN/INOUT parameters and decode them
		for (int i = 0; i < params.size(); i++)
		{
		    TriParameter param = params.get(i);
	
		    if (param.getParameterPassingMode() == TriParameterPassingMode.TRI_OUT)
		    {
			continue;
		    }
	
		    objectList.addElement(decodeEncodedParameter(
			    param.getEncodedParameter()));
		}
	
		// Convert vector to array.
		Object[] returnList = new Object[objectList.size()];
	
		for (int i = objectList.size(); i-- > 0;)
		{
		    returnList[i] = objectList.get(i);
		}
	
		// return the in parameters as objects
		return returnList;
	    }
	    */
}// end public class BGP_STATETestAdapter
