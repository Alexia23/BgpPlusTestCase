module ROUTING_FORWARDING
{
		// Common string subtypes  number indicates encoding length in number of 
		// _hex digits/chars/octets_
		type octetstring	Oct1 		length(1);
		type octetstring	Oct2 		length(2); 
		type octetstring	Oct3 		length(3); 
		type octetstring	Oct4 		length(4); 
		type octetstring	Oct6 		length(6);
		type octetstring	Oct8 		length(8); 
		type octetstring	Oct16 		length(16); 
		type octetstring	Oct128 		length(128); 
		type octetstring	Oct45 		length(45); 
		//type octetstring	Oct1to128 	length(1..128); //with {encode "1 to 128 Octets"};
		
		//group	Module_Par
		//{
			//modulepar	{Oct4	MTC_IPv4 };
			//modulepar	{Oct4	ROUTER_PCO1_IPv4 };
			//modulepar	{Oct4	PTC1_IPv4 };
			//modulepar	{Oct4	ROUTER_PCO2_IPv4 };
			/*
			const	Oct4		MTC_IPv4 := 'C0A801C3'O;			//192.168.1.195
			const 	Oct4 	ROUTER_PCO1_IPv4 := 'C0A801A5'O;	//192.168.1.165
			const 	Oct4		PTC1_IPv4	:= 'C0A80275'O;		//192.168.2.117
			const 	Oct4		ROUTER_PCO2_IPv4 := 'C0A80201'O;	//192.168.2.1	
			
			'C0A801C3'O
			'C0A801A5'O
			'C0A80275'O
			'C0A80201'O
			*/
		//}//end Module_Par*/
		group BGP_CONSTANT
		{
			const Oct2 	AS_Number_MTC	:= '0046'O;		//70
			const Oct2 	AS_Number_PTC1	:= '0050'O;		//80
			const Oct2 	AS_Number_PTC2	:= '0050'O;		//80
			const Oct2 	AS_Number_ROUTER 	:= '0001'O;	
			
			const Oct4 	MTC_IPv4		:= 'CA65010B'O;	//202.101.1.11
			const Oct4	PTC1_IPv4		:= 'CA650216'O;	//202.101.3.22
			const Oct4	PTC2_IPv4		:= '79650521'O;	//121.101.5.33
			
			const Oct4 	ROUTER_PCO1_IPv4 := 'CA650101'O;	//202.101.1.1
			const Oct4	ROUTER_PCO2_IPv4 := 'CA650301'O;	//202.101.3.1
			const Oct4	ROUTER_PCO3_IPv4 := '79650501'O;	//121.101.5.1
			
			const integer HOLD_TIMER 	:= 190;			//unit-s			
		}//end group BGP_CONSTANT
		
		group	PDU_TYPE
		{
			group	PDU_OPEN
			{
				type record BGP_OPEN
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	VERSION,
					Oct2	MY_AS,
					Oct2	HOLDTIME,
					Oct4	ID,
					Oct1	OPTION_LEN			
				}//end record BGP_OPEN
				
				type record BGP_OPEN_TEMP
				{
					Oct16	MARKER,
					Oct2		LENGTH,
					Oct1		TYPE,
					Oct1		VERSION,
					Oct2		MY_AS,
					Oct2		HOLDTIME,
					Oct4		ID,
					Oct1		OPTION_LEN,
					Oct16	TEMP
				}//end record BGP_OPEN_TEMP
			}//end group PDU_OPEN
			
			group	PDU_NOTIFICATION
			{
				type	record	BGP_NOTIFICATION
				{
					Oct16	MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct1	ERR_CODE,
					Oct1	ERR_SUBCODE
				}// end record BGP_NOTIFICATION	
			}// end group	PDU_NOTIFICATION
			
			group PDU_KEEPALIVE
			{
				type record BGP_KEEPALIVE
				{
					Oct16	MARKER,
					Oct2	LENGTH,
					Oct1	TYPE
				}//	end record BGP_KEEPALIVE				
			}// end group PDU_KEEPALIVE
			
			group	PDU_UPDATE
			{
				type	record	BGP_UPDATE_CAST
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_CAST
				
				type	record	BGP_UPDATE_ORIGIN_AS_N
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct4	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_ORIGIN_AS_N
				
				type	record	BGP_UPDATE_WITHDRAW
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct4	WITHDRAWN,
					Oct2	PATHATTRIBUTE_LEN	
				}// end record BGP_UPDATE_WITHDRAW
				
				type	record	BGP_UPDATE_WITHDRAW2
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct4	WITHDRAWN,
					Oct4	WITHDRAWN2,
					Oct2	PATHATTRIBUTE_LEN	
				}// end record BGP_UPDATE_WITHDRAW2
				
				type	record	BGP_UPDATE_ORIGIN_AS_N_ATOMIC
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct4	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	ATOMIC_AGGRE,
					Oct4	NLRI
				}// end record BGP_UPDATE_ORIGIN_AS_N_ATOMIC
				
				type	record	BGP_UPDATE_ORIGIN_AS_N_AGGRE
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct4	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	AGGREGATION,
					Oct2	AGGRE_AS,
					Oct4	AGGRE_IP,
					Oct4	NLRI
				}// end record BGP_UPDATE_ORIGIN_AS_N_AGGRE
				
				type	record	BGP_UPDATE_ORIGIN_SET_AS_N
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct1	AS2_SEG_TYPE,
					Oct1	AS2_SEG_LEN,
					Oct4	AS2_SEG_VAL,
					Oct1	AS3_SEG_TYPE,
					Oct1	AS3_SEG_LEN,
					Oct2	AS3_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_ORIGIN_SET_AS_N
				
				type	record	BGP_UPDATE_ORIGIN_AS_N_IBGP
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	LOCAL_PREF,
					Oct4	LOCAL_PREF_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_ORIGIN_AS_N_IBGP
				
				type	record	BGP_UPDATE_MED_IBGP
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct3	LOCAL_PREF,
					Oct4	LOCAL_PREF_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_MED_IBGP
								
				type	record	BGP_UPDATE_NLRI2
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct4	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI,
					Oct4	NLRI2
				}// end record BGP_UPDATE_NLRI2
				
				type	record	BGP_UPDATE_LOOP3
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct8	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI,
					Oct4	NLRI2
				}// end record BGP_UPDATE_LOOP3				
				
				type	record	BGP_UPDATE_NLRI
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI,
					Oct4	NLRI2
				}// end record BGP_UPDATE_NLRI
				
				type	record	BGP_UPDATE_ERR
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI		
					
				}// end record BGP_UPDATE_ERR
				
				type	record	BGP_UPDATE_MED
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	MED,
					Oct4	MED_VAL,
					Oct4	NLRI
				}//end record BGP_UPDATE_MED
				
				type	record	BGP_UPDATE_LOCAL_PREF
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	LOCAL_PREF,
					Oct4	LOCAL_PREF_VAL,
					Oct4	NLRI
				}//end record BGP_UPDATE_LOCAL_PREF
				
				type	record	BGP_UPDATE_ATOMIC
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	ATOMIC_AGGREGATE,
					Oct4	NLRI
				}//end record BGP_UPDATE_ATOMIC
				
				type	record	BGP_UPDATE_FOR_AGGRE
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	NLRI,
					Oct4	NLRI2
				}//end record BGP_UPDATE_FOR_AGGRE
				
				type	record	BGP_UPDATE_AGGREGATOR
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	AGGREGATION,
					Oct2	AGGRE_AS,
					Oct4	AGGRE_IP,
					Oct4	NLRI
				}// end record BGP_UPDATE_AGGREGATOR
				
				type	record	BGP_UPDATE_3AS_PATH
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct6	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_3AS_PATH	
				
				type	record	BGP_UPDATE_AS_SET
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct4	AS_SEG_VAL,
					Oct1	AS2_SEG_TYPE,
					Oct1	AS2_SEG_LEN,
					Oct2	AS2_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_AS_SET
				
				type	record	BGP_UPDATE_ORDER
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,	
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct4	NLRI
				}// end record BGP_UPDATE_ORDER
				
				type	record	BGP_UPDATE_ERR1
				{
					Oct16 MARKER,
					Oct2	LENGTH,
					Oct1	TYPE,
					Oct2	UNFEASIBLE,
					Oct2	PATHATTRIBUTE_LEN,
					Oct3	ORIGIN,
					Oct1	ORIGIN_TYPE,
					Oct2	AS_PATH,
					Oct1	AS_LEN,
					Oct1	AS_SEG_TYPE,
					Oct1	AS_SEG_LEN,
					Oct2	AS_SEG_VAL,
					Oct3	NEXT_HOP,
					Oct4	NEXT_HOT_VAL,
					Oct3	NLRI		
					
				}// end record BGP_UPDATE_ERR1
				
				
			}//end group PDU_UPADATE
			
			type record		BGP_CM
			{
				Oct1		DATA
			}
			
		}//end group PDU_TYPE
		
		
		group	TEMPL_OPEN
		{
			template	BGP_OPEN	OPEN_RECEIVE :=
			{
				MARKER 			:= ?,
				LENGTH 			:= ?,
				TYPE			:= '01'O,
				VERSION			:= '04'O,
				MY_AS			:= ?,
				HOLDTIME		:= ?,
				ID			:= ?,
				OPTION_LEN		:= ?
			};
			
			template	BGP_OPEN	OPEN_SEND :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE			:= '01'O,
				VERSION			:= '04'O,
				MY_AS			:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,	//180
				ID			:= MTC_IPv4,
				OPTION_LEN		:= '00'O
			};
			
			template	BGP_OPEN	OPEN_SEND_I :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_ROUTER,
				HOLDTIME		:= '00B4'O,	//180
				ID					:= 'CA7001E3'O,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN	OPEN_SEND_PTC1 :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE				:= '01'O,
				VERSION			:= '04'O,
				MY_AS				:= AS_Number_PTC1,
				HOLDTIME		:= '00B4'O,	//180
				ID					:= PTC1_IPv4,
				OPTION_LEN	:= '00'O
			};
			
			template	BGP_OPEN_TEMP		OPEN_SEND_TEMP :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE			:= '01'O,
				VERSION			:= '04'O,
				MY_AS			:= AS_Number_MTC,
				HOLDTIME		:= '00B4'O,	//180
				ID				:= MTC_IPv4,
				OPTION_LEN		:= '10'O,
				TEMP			:= '02060104000200010202800002020200'O
			};
			
			template	BGP_OPEN_TEMP		OPEN_SEND1_TEMP :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '001D'O,
				TYPE			:= '01'O,
				VERSION			:= '04'O,
				MY_AS			:= AS_Number_PTC1,
				HOLDTIME		:= '00B4'O,	//180
				ID				:= PTC1_IPv4,
				OPTION_LEN		:= '10'O,
				TEMP			:= '02060104000200010202800002020200'O
			};
		}//end group	TEMPL_OPEN
		
		group	TEMPL_NOTIFICATION
		{
			template	BGP_NOTIFICATION		NOTIFICATION_RECEIVE :=
			{
				MARKER			:= ?,
				LENGTH			:= ?,
				TYPE			:= '03'O,
				ERR_CODE		:= ?,
				ERR_SUBCODE	:= ?
			};
			
			template	BGP_NOTIFICATION	CEASE :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '0015'O,
				TYPE			:= '03'O,
				ERR_CODE		:= '06'O,
				ERR_SUBCODE	:= '00'O
			};
			
		}//end group TEMPL_NOTIFICATION
		
		group	TEMPL_KEEPALIVE
		{
			template	BGP_KEEPALIVE		KEEPALIVE_SEND :=
			{
				MARKER 			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH 			:= '0013'O,		//19
				TYPE			:= '04'O
			};
			
			template	BGP_KEEPALIVE		KEEPALIVE_RECEIVE :=
			{
				MARKER	:= ?,
				LENGTH	:= ?,
				TYPE	:= '04'O
			};
		}//end group TEMPL_KEEPALIVE
		             
		template		BGP_CM		CM_READY :=
		{
			DATA := '01'O
		};		
		
		group	TEMPL_UPDATE
		{
			template	BGP_UPDATE_ERR		UPDATE_RECEIVE :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= ?,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= ?,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= ?,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= ?,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ?,
				NLRI								:= ?
			};
			
			template	BGP_UPDATE_CAST		UPDATE_CAST :=
			{
				MARKER						:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH						:= ?,
				TYPE							:= '02'O,
				UNFEASIBLE				:= '0000'O,
				PATHATTRIBUTE_LEN	:= ?,
				ORIGIN						:= '400101'O,
				ORIGIN_TYPE				:= '00'O,
				AS_PATH						:= '4002'O,
				AS_LEN						:= '04'O,
				AS_SEG_TYPE				:= '02'O,
				AS_SEG_LEN				:= '01'O,
				AS_SEG_VAL				:= '0001'O,
				NEXT_HOP					:= '400304'O,
				NEXT_HOT_VAL			:= ROUTER_PCO1_IPv4,
				MED								:= '800404'O,
				MED_VAL						:= ?,
				NLRI							:= ?
			};
			
			template	BGP_UPDATE_ERR		UPDATE_ORIGIN_0 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N		UPDATE_ORIGIN0_AS_N :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002F'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0014'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				NLRI								:= '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_ERR		UPDATE_ORIGIN_1 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '01'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N		UPDATE_ORIGIN1_AS_N :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002F'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0014'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '01'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				NLRI								:= '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_ERR		UPDATE_ORIGIN_2 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '02'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:=  '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N		UPDATE_ORIGIN2_AS_N :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002F'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0014'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '02'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				NLRI								:= '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_WITHDRAW	UPDATE_WITHDRAW :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '001B'O,
				TYPE			:= '02'O,
				UNFEASIBLE		:= '0004'O,
				WITHDRAWN		:= '18C0A801'O,	//24/192.168.1
				PATHATTRIBUTE_LEN	:= '0000'O	
			};
			
			template	BGP_UPDATE_WITHDRAW	UPDATE_WITHDRAW_1 :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '001B'O,
				TYPE			:= '02'O,
				UNFEASIBLE		:= '0004'O,
				WITHDRAWN		:= '14A66F80'O,
				PATHATTRIBUTE_LEN	:= '0000'O	
			};
			
			template	BGP_UPDATE_WITHDRAW2	UPDATE_WITHDRAW_2 :=
			{
				MARKER			:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH			:= '001F'O,
				TYPE			:= '02'O,
				UNFEASIBLE		:= '0008'O,
				WITHDRAWN		:= '14A66F80'O,
				WITHDRAWN2		:= '18A66FA3'O,
				PATHATTRIBUTE_LEN	:= '0000'O	
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N_ATOMIC	UPDATE_ORIGIN_AS_N_ATOMIC :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0032'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0017'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				ATOMIC_AGGRE						:= '400600'O,
				NLRI								:= '18C0A801'O	//24/192.168.1
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N_AGGRE	UPDATE_ORIGIN_AS_N_AGGRE :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0038'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '001D'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				AGGREGATION					:= 'C00706'O,
				AGGRE_AS						:= AS_Number_PTC1,
				AGGRE_IP						:= PTC1_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ORIGIN_SET_AS_N	UPDATE_AS_SET_PTC :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0037'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '001C'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '0E'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= '0001'O,
				AS2_SEG_TYPE					:= '01'O,
				AS2_SEG_LEN					:= '02'O,
				AS2_SEG_VAL					:= '0014001E'O,
				AS3_SEG_TYPE					:= '02'O,
				AS3_SEG_LEN					:= '01'O,
				AS3_SEG_VAL					:= '0046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N	UPDATE_THIRD_NEXT_HOP :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002F'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0014'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N_IBGP	UPDATE_ORIGIN_AS_N_IBGP :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0036'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '001B'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010050'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO1_IPv4,
				LOCAL_PREF					:= '400504'O,
				LOCAL_PREF_VAL					:= '00000007'O,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_MED_IBGP	UPDATE_MED_IBGP :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '003B'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0020'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= '0050'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= PTC1_IPv4,
				MED					:= '800404'O,
				MED_VAL					:= ?,
				LOCAL_PREF					:= '400504'O,
				LOCAL_PREF_VAL					:= ?,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_NLRI2	UPDATE_NLRI2 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0033'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0014'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00010046'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= ROUTER_PCO2_IPv4,
				NLRI								:= '14A66F80'O,
				NLRI2								:= '18A66FA3'O
			};
			
			template	BGP_UPDATE_MED		UPDATE_MED :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0034'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0019'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				MED									:= '800404'O,
				MED_VAL							:= '00000007'O,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_LOCAL_PREF		UPDATE_LOCAL_PREF_I :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0034'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0019'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				LOCAL_PREF					:= '400504'O,
				LOCAL_PREF_VAL			:= '00000007'O,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ATOMIC		UPDATE_ATOMIC_AGGRE_R :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0030'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0015'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				ATOMIC_AGGREGATE		:= '400600'O,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_AGGREGATOR		UPDATE_AGGREGATION :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0036'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '001B'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				AGGREGATION					:= 'C00706'O,
				AGGRE_AS						:= AS_Number_PTC1,
				AGGRE_IP						:= PTC1_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_LOOP :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				//LENGTH							:= '002C'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				//NLRI								:= '10CA65'O
				NLRI								:= '18CA6501'O
			};
			
			template	BGP_UPDATE_ORIGIN_AS_N		UPDATE_LOOP1 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002F'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0014'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '01'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '06'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '00500001'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_3AS_PATH	UPDATE_LOOP2 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0031'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0016'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '08'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '03'O,
				AS_SEG_VAL					:= '00500001005A'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_LOOP3	UPDATE_LOOP3 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0033'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0018'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '0A'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= '005001020001005A'O,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_NLRI	UPDATE_NLRI_2 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0031'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '14A66F80'O,
				NLRI2								:= '18A66FA3'O
			};
			
			template	BGP_UPDATE_AS_SET	UPDATE_AS_SET :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0033'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0018'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '0A'O,
				AS_SEG_TYPE					:= '01'O,
				AS_SEG_LEN					:= '02'O,
				AS_SEG_VAL					:= '0014001E'O,
				AS2_SEG_TYPE				:= '02'O,
				AS2_SEG_LEN					:= '01'O,
				AS2_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_R_3TH_NEXTHOP :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI								:= '18C0A801'O
			};
			
			template	BGP_UPDATE_ERR		UPDATE_R_3TH_NEXTHOP1 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '002D'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP						:= '400304'O,
				NEXT_HOT_VAL				:= 'A66F4401'O,	//166.111.68.1
				NLRI								:= '18C0A801'O
			};
								
			template	BGP_UPDATE_ORDER		UPDATE_OUT_ORDER :=
			{
				MARKER	:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH	:= '002D'O,
				TYPE	:= '02'O,	
				UNFEASIBLE	:= '0000'O,
				PATHATTRIBUTE_LEN	:='0012'O,
				AS_PATH	:= '4002'O,
				AS_LEN	:= '04'O,
				AS_SEG_TYPE	:= '02'O,
				AS_SEG_LEN	:= '01'O,
				AS_SEG_VAL	:= AS_Number_MTC,
				ORIGIN	:= '400101'O,
				ORIGIN_TYPE	:= '00'O,
				NEXT_HOP	:= '400304'O,
				NEXT_HOT_VAL	:= MTC_IPv4,
				NLRI	:= '18C0A801'O
			};
			
			template	BGP_UPDATE_FOR_AGGRE		UPDATE_FOR_AGGRE1 :=
			{
				MARKER							:= 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'O,
				LENGTH							:= '0030'O,
				TYPE								:= '02'O,
				UNFEASIBLE					:= '0000'O,
				PATHATTRIBUTE_LEN		:= '0012'O,
				ORIGIN							:= '400101'O,
				ORIGIN_TYPE					:= '00'O,
				AS_PATH							:= '4002'O,
				AS_LEN							:= '04'O,
				AS_SEG_TYPE					:= '02'O,
				AS_SEG_LEN					:= '01'O,
				AS_SEG_VAL					:= AS_Number_MTC,
				NEXT_HOP					:= '400304'O,
				NEXT_HOT_VAL				:= MTC_IPv4,
				NLRI							:= '10A66F'O,
				NLRI2						:= '18A66F88'O
			};
						
		}//end group TEMPL_UPADATE
		
		
		group	Port
		{
			type port	BGP_Port		message
			{
				inout	all;
			}
			
		}//end group Port
		
		group	TestAbstractComponent
		{
			type component	BGP_Component
			{
				port		BGP_Port		BGP_port_map;
				port		BGP_Port		BGP_port_connect;
				timer	BGP_Timer_Hold 		:= 190;
				timer	BGP_Timer_KeepAlive 	:= 60; //unit-s
				timer	Timer_Keepalive_Nego	 := 25;
			
			}
			
			type component	BGP_PTC_Component
			{
				port		BGP_Port		BGP_PTC_port_map;
				port		BGP_Port		BGP_PTC_port_connect;
				timer	BGP_PTC_Timer_Hold 		:= 190;
				timer	BGP_PTC_Timer_KeepAlive 	:= 60; //unit-s
				timer	BGP_PTC_Timer_Keepalive_Nego	 := 25;
				timer	BGP_ConnectTimer	 := 7;
			
			}
		}	//end group TestAbstractComponent
		
		group	TestSystemInterface
		{
			type component BGP_Interface
			{
				port 	BGP_Port		BGP_Interface_Port; 
				port		BGP_Port		BGP_Interface_Port2;
			}
		}//end group TestSystemInterface
		
		group	MyFunctions
		{
			function	fun_ESTABLISHED_PCO1() runs on BGP_Component
			{
				BGP_port_map.send(OPEN_SEND);
				BGP_Timer_Hold.start;
				alt	//01
				{//wait for receive open frame
					[]BGP_port_map.receive(OPEN_RECEIVE)
					{					
						BGP_Timer_Hold.start;
						alt	//02
						{//wait for receive keepalive frame
							[]BGP_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_port_map.send(KEEPALIVE_SEND);
							}
							[]BGP_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}
							[]BGP_port_map.receive	
							{
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}//end alt 01
					[]BGP_Timer_Hold.timeout
					{
						setverdict(fail);
						stop;
					}	
					[]BGP_port_map.receive	
					{
						setverdict(fail);
						stop;
					}	
				}
			}// end function	fun_ESTABLISHED_PCO1()
			
			function	fun_ESTABLISHED_PCO2() runs on BGP_PTC_Component
			{
				BGP_PTC_port_map.send(OPEN_SEND_PTC1);
				BGP_PTC_Timer_Hold.start;
				alt	//01
				{//wait for receive open frame
					[]BGP_PTC_port_map.receive(OPEN_RECEIVE)
					{					
						BGP_PTC_Timer_Hold.start;
						alt	//02
						{//wait for receive keepalive frame
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}
							[]BGP_PTC_port_map.receive	
							{
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}//end alt 01
					[]BGP_PTC_Timer_Hold.timeout
					{
						setverdict(fail);
						stop;
					}	
					[]BGP_PTC_port_map.receive	
					{
						setverdict(fail);
						stop;
					}	
				}
			}// end function	fun_ESTABLISHED_PCO2()
		
		
			function	fun_ptc_UPDATE_ORIGIN0_AS_N() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN0_AS_N)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_ORIGIN0_AS_N
			
			function	fun_ptc_UPDATE_ORIGIN1_AS_N() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN1_AS_N)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_ORIGIN1_AS_N
			
			function	fun_ptc_UPDATE_ORIGIN2_AS_N() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN2_AS_N)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_ORIGIN2_AS_N
			
			function	fun_ptc_WITHDRAW_ORIGIN_AS_N()	runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						BGP_PTC_Timer_KeepAlive.start;
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN0_AS_N)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								label	L2;
								alt	//03
								{
									[]BGP_PTC_port_map.receive(UPDATE_WITHDRAW)
									{
										setverdict(pass);
										stop;
									}
									[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
									{
										BGP_PTC_port_map.send(KEEPALIVE_SEND);
										HoldTimerValue := HoldTimerValue - KeepTimerValue;
										BGP_PTC_Timer_Hold.start(HoldTimerValue);
										goto	L2;
									}
									[]BGP_PTC_port_map.receive
									{
										setverdict(fail);
										stop;
									}
									[]BGP_PTC_Timer_Hold.timeout
									{
										setverdict(fail);
										stop;
									}
								}//end alt 03
							}
							[]BGP_PTC_Timer_KeepAlive.timeout
							{
								setverdict(fail);
								stop;
							}
							[]BGP_PTC_port_map.receive
							{
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}//end function fun_ptc_WITHDRAW_ORIGIN_AS_N
			
			function	fun_ptc_UPDATE_MED() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN_AS_N_ATOMIC)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_MED
			
			function	fun_ptc_UPDATE_LOCAL_PREF() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN0_AS_N)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_LOCAL_PREF
			
			function	fun_ptc_UPDATE_ATOMIC() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN_AS_N_ATOMIC)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_ATOMIC
			
			function	fun_ptc_UPDATE_AGGREGATION() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN_AS_N_AGGRE)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_AGGREGATION
			
			function	fun_ptc_UPDATE_LOOP() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						BGP_PTC_Timer_KeepAlive.start;
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								BGP_PTC_Timer_KeepAlive.start;
								alt	//03
								{
									[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
									{
										setverdict(pass);
										stop;
									}
									[]BGP_PTC_port_map.receive
									{
										setverdict(fail);
										stop;
									}
									[]BGP_PTC_Timer_KeepAlive.timeout
									{
										setverdict(inconc);
										stop;
									}
								}//end alt 03
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_Timer_KeepAlive.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_LOOP
			
			function	fun_ptc_UPDATE_NLRI2() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_NLRI2)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_NLRI2
			
			function	fun_ptc_DRAW1_NLRI2()	runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						BGP_PTC_Timer_KeepAlive.start;
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_NLRI2)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								label	L2;
								alt	//03
								{
									[]BGP_PTC_port_map.receive(UPDATE_WITHDRAW_1)
									{
										setverdict(pass);
										stop;
									}
									[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
									{
										BGP_PTC_port_map.send(KEEPALIVE_SEND);
										HoldTimerValue := HoldTimerValue - KeepTimerValue;
										BGP_PTC_Timer_Hold.start(HoldTimerValue);
										goto	L2;
									}
									[]BGP_PTC_port_map.receive
									{
										setverdict(fail);
										stop;
									}
									[]BGP_PTC_Timer_Hold.timeout
									{
										setverdict(fail);
										stop;
									}
								}//end alt 03
							}
							[]BGP_PTC_Timer_KeepAlive.timeout
							{
								setverdict(fail);
								stop;
							}
							[]BGP_PTC_port_map.receive
							{
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}//end function fun_ptc_DRAW1_NLRI2
			
			function	fun_ptc_DRAW2_NLRI2()	runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						BGP_PTC_Timer_KeepAlive.start;
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_NLRI2)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								label	L2;
								alt	//03
								{
									[]BGP_PTC_port_map.receive(UPDATE_WITHDRAW_2)
									{
										setverdict(pass);
										stop;
									}
									[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
									{
										BGP_PTC_port_map.send(KEEPALIVE_SEND);
										HoldTimerValue := HoldTimerValue - KeepTimerValue;
										BGP_PTC_Timer_Hold.start(HoldTimerValue);
										goto	L2;
									}
									[]BGP_PTC_port_map.receive
									{
										setverdict(fail);
										stop;
									}
									[]BGP_PTC_Timer_Hold.timeout
									{
										setverdict(fail);
										stop;
									}
								}//end alt 03
							}
							[]BGP_PTC_Timer_KeepAlive.timeout
							{
								setverdict(fail);
								stop;
							}
							[]BGP_PTC_port_map.receive
							{
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}//end function fun_ptc_DRAW2_NLRI2
			
			function	fun_ptc_SAME_NLRI()	runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						BGP_PTC_Timer_KeepAlive.start;
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_KeepAlive.start;
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_ORIGIN0_AS_N)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								label	L2;
								alt	//03
								{
									[]BGP_PTC_port_map.receive(UPDATE_ORIGIN_AS_N_ATOMIC)
									{
										setverdict(pass);
										stop;
									}
									[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
									{
										BGP_PTC_port_map.send(KEEPALIVE_SEND);
										HoldTimerValue := HoldTimerValue - KeepTimerValue;
										BGP_PTC_Timer_Hold.start(HoldTimerValue);
										goto	L2;
									}
									[]BGP_PTC_port_map.receive
									{
										setverdict(fail);
										stop;
									}
									[]BGP_PTC_Timer_Hold.timeout
									{
										setverdict(fail);
										stop;
									}
								}//end alt 03
							}
							[]BGP_PTC_Timer_KeepAlive.timeout
							{
								setverdict(fail);
								stop;
							}
							[]BGP_PTC_port_map.receive
							{
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}//end function fun_ptc_SAME_NLRI
			
			function	fun_ptc_UPDATE_ASPATH() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_AS_SET_PTC)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_ASPATH
			
			function	fun_ptc_UPDATE_3TH_NEXTHOP() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_THIRD_NEXT_HOP)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_UPDATE_3TH_NEXTHOP
			
			function	fun_ptc_FOR_AGGRE() runs on BGP_PTC_Component
			{
				var 	integer	HoldTimerValue := 190;
				var	integer	KeepTimerValue := 60;
								
				fun_ESTABLISHED_PCO2();
				
				BGP_ConnectTimer.start;
				alt	//01
				{
					[]BGP_PTC_port_connect.receive(CM_READY)
					{
						HoldTimerValue := HOLD_TIMER;
						BGP_PTC_Timer_Hold.start(HoldTimerValue);
						label	L1;
						alt	//02
						{
							[]BGP_PTC_port_map.receive(KEEPALIVE_RECEIVE)
							{
								BGP_PTC_port_map.send(KEEPALIVE_SEND);
								HoldTimerValue := HoldTimerValue - KeepTimerValue;
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_CAST)
							{
								BGP_PTC_Timer_Hold.start(HoldTimerValue);
								goto	L1;
							}
							[]BGP_PTC_port_map.receive(UPDATE_RECEIVE)
							{
								setverdict(pass);
								stop;
							}
							[]BGP_PTC_Timer_Hold.timeout	
							{
								setverdict(fail);
								stop;
							}	
							[]BGP_PTC_port_map.receive	
							{					
								setverdict(fail);
								stop;
							}
						}//end alt 02
					}
					[]BGP_ConnectTimer.timeout
					{
						setverdict(fail);
						stop;
					}
				}//end alt 01
			}// end function fun_ptc_FOR_AGGRE
			
		}//end group Functions
		
		group	Testcases
		{
			testcase		R_UPDATE_ORIGIN0_AS_N()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_ORIGIN0_AS_N());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_ORIGIN_0);
				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_ORIGIN0_AS_N
			
			testcase		R_UPDATE_ORIGIN1_AS_N()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_ORIGIN1_AS_N());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_ORIGIN_1);
				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_ORIGIN1_AS_N
			
			testcase		R_UPDATE_ORIGIN2_AS_N()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_ORIGIN2_AS_N());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_ORIGIN_2);
				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_ORIGIN2_AS_N
			
			testcase		R_WITHDRAW_ORIGIN_AS_N()	runs on BGP_Component	system BGP_Interface	
			{
				var	integer	Timer_10 := 10;
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_WITHDRAW_ORIGIN_AS_N());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_ORIGIN_0);
				
				BGP_Timer_Hold.start(Timer_10);
				alt	//01
				{
					[]BGP_Timer_Hold.timeout
					{
						BGP_port_map.send(UPDATE_WITHDRAW);
						alt	//02
						{
							[]v_ptc.done
							{
								stop;
							}
						}//end alt 02
					}
				}//end alt 01
			}//end testcase R_WITHDRAW_ORIGIN_AS_N
			/*
			testcase		R_UPDATE_MED()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_MED());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_MED);
				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_MED
			*/
			
			testcase		R_UPDATE_LOCAL_PREF()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_LOCAL_PREF());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_LOCAL_PREF_I);
				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_LOCAL_PREF
			
			testcase		R_UPDATE_ATOMIC()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_ATOMIC());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_ATOMIC_AGGRE_R);
				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_ATOMIC
			
			testcase		R_UPDATE_AGGREGATION()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_AGGREGATION());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_AGGREGATION);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_AGGREGATION
			
			testcase		R_UPDATE_LOOP()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_LOOP());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_LOOP);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_LOOP
			
			testcase		R_UPDATE_LOOP1()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_LOOP());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_LOOP1);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_LOOP1
			
			testcase		R_UPDATE_LOOP2()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_LOOP());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_LOOP2);
				label	L1;
				alt
				{
					[]BGP_port_map.receive
					{
						goto	L1;
					}				
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_LOOP2
			
			testcase		R_UPDATE_LOOP3()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_LOOP());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_LOOP3);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_LOOP3
			
			testcase		R_UPDATE_NLRI2()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_NLRI2());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_NLRI_2);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_NLRI2
			
			testcase		R_DRAW1_NLRI2()	runs on BGP_Component	system BGP_Interface	
			{
				var	integer	Timer_10 := 10;
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_DRAW1_NLRI2());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_NLRI_2);
				BGP_Timer_Hold.start(Timer_10);
				alt	//01
				{
					[]BGP_Timer_Hold.timeout
					{
						BGP_port_map.send(UPDATE_WITHDRAW_1);
						alt	//02
						{
							[]v_ptc.done
							{
								stop;
							}
						}//end alt 02
					}
				}//end alt 01				
			}//end testcase R_DRAW1_NLRI2
			
			testcase		R_DRAW2_NLRI2()	runs on BGP_Component	system BGP_Interface	
			{
				var	integer	Timer_10 := 10;
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_DRAW2_NLRI2());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_NLRI_2);
				BGP_Timer_Hold.start(Timer_10);
				alt	//01
				{
					[]BGP_Timer_Hold.timeout
					{
						BGP_port_map.send(UPDATE_WITHDRAW_2);
						alt	//02
						{
							[]v_ptc.done
							{
								stop;
							}
						}//end alt 02
					}
				}//end alt 01				
			}//end testcase R_DRAW2_NLRI2
			
			testcase		R_SAME_NLRI()	runs on BGP_Component	system BGP_Interface	
			{
				var	integer	Timer_10 := 10;
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_SAME_NLRI());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_ORIGIN_0);
				BGP_Timer_Hold.start(Timer_10);
				alt	//01
				{
					[]BGP_Timer_Hold.timeout
					{
						BGP_port_map.send(UPDATE_ATOMIC_AGGRE_R);
						alt	//02
						{
							[]v_ptc.done
							{
								stop;
							}
						}//end alt 02
					}
				}//end alt 01				
			}//end testcase R_SAME_NLRI
			
			testcase		R_UPDATE_ASPATH()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_ASPATH());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_AS_SET);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_ASPATH
			
			testcase		R_UPDATE_3TH_NEXTHOP()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_3TH_NEXTHOP());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_R_3TH_NEXTHOP);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_3TH_NEXTHOP
			
			testcase		R_UPDATE_3TH_NEXTHOP1()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_LOOP());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_R_3TH_NEXTHOP1);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_3TH_NEXTHOP1
			
			testcase		R_UPDATE_OUT_ORDER()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_UPDATE_ORIGIN0_AS_N());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_OUT_ORDER);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_UPDATE_OUT_ORDER
			
			testcase		R_FOR_AGGRE()	runs on BGP_Component	system BGP_Interface	
			{
				var	BGP_PTC_Component	v_ptc := BGP_PTC_Component.create;
							
				connect(self:BGP_port_connect, v_ptc:BGP_PTC_port_connect);
				
				map(mtc:BGP_port_map, system:BGP_Interface_Port);
				
				map(v_ptc:BGP_PTC_port_map, system:BGP_Interface_Port2);
				
				v_ptc.start(fun_ptc_FOR_AGGRE());			
				
				BGP_port_connect.send(CM_READY);
				
				fun_ESTABLISHED_PCO1();
				
				BGP_port_map.send(UPDATE_FOR_AGGRE1);				
				alt
				{
					[]v_ptc.done
					{
						stop;
					}
				}
			}//end testcase R_FOR_AGGRE
			
		}//end group Testcases
				
}//end module ROUTING_FORWARDING
